# 工作流名称
name: Build, Test and Package

# 触发工作流的事件
on:
  push:
    branches: [ main, view, model, model_viewmodel ] # 对这些分支的 push 会触发
  pull_request:
    branches: [ main ] # 对 main 分支的 PR 会触发

jobs:
  # =========================================
  # Job 1: 编译项目
  # =========================================
  build:
    runs-on: windows-latest
    
    steps:
    - name: 1. 检出代码
      uses: actions/checkout@v4

    - name: 2. 安装 Vcpkg 并设置环境变量
      shell: powershell
      run: |
        git clone https://github.com/microsoft/vcpkg.git
        cd vcpkg
        ./bootstrap-vcpkg.bat
        echo "VCPKG_ROOT=$PWD" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        cd ..

    - name: 3. 使用 CMake 配置项目
      shell: powershell
      run: |
        cmake -B ${{ github.workspace }}/build `
              -G "Visual Studio 17 2022" `
              -A x64 `
              -DCMAKE_TOOLCHAIN_FILE="${env:VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"

    - name: 4. 编译项目 (Debug)
      run: cmake --build ${{ github.workspace }}/build --config Debug

    - name: 5. 上传构建产物
      # 将整个 build 目录上传，以便 test 和 package Job 可以使用
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: ${{ github.workspace }}/build/

  # =========================================
  # Job 2: 运行测试并发布报告
  # =========================================
  test:
    # 'needs: build' 表示这个 Job 必须在 'build' Job 成功后才能开始
    needs: build
    runs-on: windows-latest
    
    # 为这个 Job 单独设置权限，允许它写入测试报告
    permissions:
      checks: write
      pull-requests: write

    steps:
    - name: 1. 检出代码
      # 这是修复错误的关键步骤。test-reporter action 需要访问 .git 目录来获取提交信息。
      uses: actions/checkout@v4

    - name: 2. 下载构建产物
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
        path: ${{ github.workspace }}/build/

    - name: 3. 运行 CTest 并生成报告
      # 即使没有找到测试，也让这一步继续，而不是失败
      continue-on-error: true
      working-directory: ${{ github.workspace }}/build
      run: ctest --test-dir . -C Debug --output-on-failure --verbose --output-junit test_results.xml

    - name: 4. 发布测试结果
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: Test Results # 报告的名称
        path: build/test_results.xml
        reporter: java-junit
        # [修复] 如果找不到测试报告文件或报告为空，不要让工作流失败
        fail-on-error: false

  # =========================================
  # Job 3: 打包可运行的程序
  # =========================================
  package:
    needs: build
    runs-on: windows-latest

    steps:
    - name: 1. 下载构建产物
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
        path: ${{ github.workspace }}/

    - name: 2. 定义目标打包目录
      # [修复] 我们将所有东西都放进 .exe 所在的目录
      id: set_paths
      shell: powershell
      run: |
        $targetDir = "${{ github.workspace }}/build/code/Debug"
        echo "target_dir=$targetDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

    - name: 3. 查找并复制所有依赖的 DLLs 到目标目录
      shell: powershell
      run: |
        $targetDir = "${{ env.target_dir }}"
        # 复制 VC++ 运行时库
        $vsWherePath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        $vsInstallPath = &$vsWherePath -latest -property installationPath
        $vcDllPath = (Get-ChildItem -Path "$vsInstallPath\VC\Redist\MSVC\*\x64\Microsoft.VC143.CRT\*.dll" | Select-Object -First 1).DirectoryName
        if ($vcDllPath) {
          echo "Copying VC++ runtime DLLs from $vcDllPath"
          Copy-Item -Path "$vcDllPath\*.dll" -Destination $targetDir
        }
        
        # 复制 vcpkg 安装的库的 DLL
        $vcpkgDllPath = "${{ github.workspace }}/build/vcpkg_installed/x64-windows/bin"
        if (Test-Path $vcpkgDllPath) {
          echo "Copying vcpkg DLLs from $vcpkgDllPath"
          Copy-Item -Path "$vcpkgDllPath\*.dll" -Destination $targetDir
        }

    - name: 4. 复制可能的资源文件到目标目录
      # [修复] 即使您认为没有，这个步骤也能防止因潜在的、被遗忘的资源文件而导致的崩溃
      shell: powershell
      run: |
        $targetDir = "${{ env.target_dir }}"
        $assetsDir = "${{ github.workspace }}/assets"
        if (Test-Path $assetsDir) {
          echo "Copying assets folder to $targetDir"
          Copy-Item -Path "$assetsDir\*" -Destination $targetDir -Recurse
        }

    - name: 5. 将最终的可运行文件夹打包上传
      uses: actions/upload-artifact@v4
      with:
        name: LevelDevil-Debug-Runnable
        path: ${{ steps.set_paths.outputs.target_dir }}
